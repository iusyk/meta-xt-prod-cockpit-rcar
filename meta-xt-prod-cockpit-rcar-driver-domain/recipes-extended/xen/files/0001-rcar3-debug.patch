From 9cb1e020046c23ef809fee6034c364d07f74a397 Mon Sep 17 00:00:00 2001
From: Ihor Usyk <ihor_usyk@epam.com>
Date: Thu, 15 Dec 2022 20:05:10 +0100
Subject: [PATCH] rcar3 debug

Signed-off-by: Ihor Usyk <ihor.usyk@gmail.com>
---
 xen/arch/arm/platforms/rcar3.c | 66 ++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/xen/arch/arm/platforms/rcar3.c b/xen/arch/arm/platforms/rcar3.c
index 4b1136c266..899cd7a2f5 100644
--- a/xen/arch/arm/platforms/rcar3.c
+++ b/xen/arch/arm/platforms/rcar3.c
@@ -55,6 +55,42 @@
 
 #define RPROC_SMC_ERR_NOT_AVAILABLE      0x01
 
+/*
+ * The set of macroses to set the information about the operation
+ * made with domain. The information is necessary to inform the cluster_wrapper
+ * about the domain status
+ * The bits from 0-3 are to save the domain ID
+ * The bits from 30-31 are to save the command
+ * Bit 30 value 1 - domain is removed
+ * Bit 31 value 1 - domain is created
+ * */
+#define SET_BIT(v,n) v |= 1UL << n
+#define IS_BIT_SET(v,n) (v >> n) & 1U
+#define RESET_BIT(v,n) v ^= 1UL << n;
+
+#define NO_OPERATION(v) (!(IS_BIT_SET(v,30)) && !(IS_BIT_SET(v,31)));
+
+#define SET_DOMAIN_CREATE(v) SET_BIT(v,31)
+#define SET_DOMAIN_REMOVE(v) SET_BIT(v,30)
+#define SET_DOMAIN_REMOVED(v) SET_BIT(v,30); \
+                              SET_BIT(v,31)
+
+#define RESET_DOMAIN_CREATE(v) RESET_BIT(v,31)
+#define RESET_DOMAIN_REMOVE(v) RESET_BIT(v,30)
+
+#define SET_DOMD(v) SET_BIT(v,0)
+#define SET_DOMA(v) SET_BIT(v,1)
+
+#define RESET_DOMD(v) RESET_BIT(v,0)
+#define RESET_DOMA(v) RESET_BIT(v,1)
+
+#define IS_DOMD_SET(v) IS_BIT_SET(v,0)
+#define IS_DOMA_SET(v) IS_BIT_SET(v,1)
+
+#define IS_DOMAIN_CREATE(v) IS_BIT_SET(v,31)
+#define IS_DOMAIN_REMOVE(v) IS_BIT_SET(v,30)
+#define IS_DOMAIN_REMOVED(v) IS_BIT_SET(v,30) && IS_BIT_SET(v,31)
+
 struct mfis_data
 {
     void *base;
@@ -125,6 +161,8 @@ static const char *const rcar3_dt_compat[] __initconst =
     NULL
 };
 
+static spinlock_t remove_domain_lock = SPIN_LOCK_UNLOCKED;
+
 static void mfis_irq_handler(int irq, void *dev_id, struct cpu_user_regs *regs)
 {
     int i;
@@ -177,11 +215,39 @@ static int mfis_add_domain(struct domain* d, int chan)
 
 static int mfis_remove_domain(int chan)
 {
+    uint32_t msg = 0x0;
+    //int reinit = 0x0;
 
     if ( chan >= mfis_data->chan_cnt )
         return -EINVAL;
 
     mfis_data->domains[chan] = NULL;
+    spin_lock(&remove_domain_lock);
+    SET_DOMAIN_REMOVE(msg);
+    msg |= (chan + 1);
+
+    printk("Fire remove domain %d\n", (chan+1));
+
+    writel(msg, mfis_data->base + MFIS_IMBR(7));
+    writel(0x1, mfis_data->base + MFIS_IICR(7));
+    // wait the end of the
+
+    printk(XENLOG_INFO"Waiting for feedback \n");
+
+    RESET_DOMAIN_REMOVE(msg);
+
+    do
+    {
+        msg = readl(mfis_data->base + MFIS_IMBR(7));
+    } while (IS_DOMAIN_REMOVED(msg));//!reinit);
+
+    printk(XENLOG_INFO"Reset... \n");
+
+    writel(0x0, mfis_data->base + MFIS_IMBR(7));
+
+    spin_unlock(&remove_domain_lock);
+
+    //writel(0x0, mfis_data->base + MFIS_IICR(6));
 
     return 0;
 }
-- 
2.25.1

